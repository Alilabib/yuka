(function(global,factory){typeof exports==="object"&&typeof module!=="undefined"?factory(exports):typeof define==="function"&&define.amd?define(["exports"],factory):factory(global.YUKA=global.YUKA||{})})(this,function(exports){"use strict";class Telegram{constructor(senderId,receiverId,message,data,delay){this.senderId=senderId;this.receiverId=receiverId;this.message=message;this.data=data;this.delay=delay}}class MessageDispatcher{constructor(entityManager){this.delayedTelegrams=new Array;this.entityManager=entityManager}deliver(receiver,telegram){if(receiver.handleMessage(telegram)===false){console.warn("YUKA.MessageDispatcher: Message not handled by receiver: %o",receiver)}}dispatch(sender,receiver,message,delay,data){const telegram=new Telegram(sender.id,receiver.id,message,data,0);if(delay<=0){this.deliver(receiver,telegram)}else{telegram.delay=delay;this.delayedTelegrams.push(telegram)}}dispatchDelayedMessages(delta){let i=this.delayedTelegrams.length;while(i--){const telegram=this.delayedTelegrams[i];telegram.delay-=delta;if(telegram.delay<=0){const receiver=this.entityManager.getEntityById(telegram.receiverId);this.deliver(receiver,telegram);this.delayedTelegrams.pop()}}}}class EntityManager{constructor(){this.entities=new Map;this.tagDirectory=new Map;this.messageDispatcher=new MessageDispatcher(this)}add(entity){this.entities.set(entity.id,entity);entity.manager=this;const tag=entity.tag;if(this.tagDirectory.has(tag)===true){const entities=this.tagDirectory.get(tag);entities.add(entity)}else{const entities=new Set;entities.add(entity);this.tagDirectory.set(tag,entities)}return this}remove(entity){this.entities.delete(entity.id);entity.manager=null;const tag=entity.tag;const entities=this.tagDirectory.get(tag);if(entities.size===1){this.tagDirectory.delete(tag)}else{entities.delete(entity)}return this}getEntityById(id){return this.entities.get(id)}getEntityByName(name){for(let entity of this.entities.values()){if(entity.name===name)return entity}return null}getEntitiesByTag(tag){const entities=this.tagDirectory.get(tag);return Array.from(entities)}update(delta){for(let entity of this.entities.values()){entity.update(delta);entity.updateMatrix()}this.messageDispatcher.dispatchDelayedMessages(delta)}sendMessage(sender,receiver,message,delay,data){this.messageDispatcher.dispatch(sender,receiver,message,delay,data)}}const _Math={clamp:(value,min,max)=>{return Math.max(min,Math.min(max,value))},randFloat:(min,max)=>{return min+Math.random()*(max-min)}};class Vector3{constructor(x=0,y=0,z=0){this.x=x;this.y=y;this.z=z}set(x,y,z){this.x=x;this.y=y;this.z=z;return this}copy(v){this.x=v.x;this.y=v.y;this.z=v.z;return this}add(v){this.x+=v.x;this.y+=v.y;this.z+=v.z;return this}addScalar(s){this.x+=s;this.y+=s;this.z+=s;return this}addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;return this}sub(v){this.x-=v.x;this.y-=v.y;this.z-=v.z;return this}subScalar(s){this.x-=s;this.y-=s;this.z-=s;return this}subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;return this}multiply(v){this.x*=v.x;this.y*=v.y;this.z*=v.z;return this}multiplyScalar(s){this.x*=s;this.y*=s;this.z*=s;return this}multiplyVectors(a,b){this.x=a.x*b.x;this.y=a.y*b.y;this.z=a.z*b.z;return this}divide(v){this.x/=v.x;this.y/=v.y;this.z/=v.z;return this}divideScalar(s){this.x/=s;this.y/=s;this.z/=s;return this}divideVectors(a,b){this.x=a.x/b.x;this.y=a.y/b.y;this.z=a.z/b.z;return this}dot(v){return this.x*v.x+this.y*v.y+this.z*v.z}cross(v){const x=this.x,y=this.y,z=this.z;this.x=y*v.z-z*v.y;this.y=z*v.x-x*v.z;this.z=x*v.y-y*v.x;return this}crossVectors(a,b){const ax=a.x,ay=a.y,az=a.z;const bx=b.x,by=b.y,bz=b.z;this.x=ay*bz-az*by;this.y=az*bx-ax*bz;this.z=ax*by-ay*bx;return this}angleTo(v){const theta=this.dot(v)/Math.sqrt(this.lengthSq()*v.lengthSq());return Math.acos(_Math.clamp(theta,-1,1))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this.dot(this)}distanceTo(v){return Math.sqrt(this.distanceToSquared(v))}distanceToSquared(v){const dx=this.x-v.x,dy=this.y-v.y,dz=this.z-v.z;return dx*dx+dy*dy+dz*dz}normalize(){return this.divideScalar(this.length()||1)}applyMatrix4(m){const x=this.x,y=this.y,z=this.z;const e=m.elements;const w=1/(e[3]*x+e[7]*y+e[11]*z+e[15]);this.x=(e[0]*x+e[4]*y+e[8]*z+e[12])*w;this.y=(e[1]*x+e[5]*y+e[9]*z+e[13])*w;this.z=(e[2]*x+e[6]*y+e[10]*z+e[14])*w;return this}applyQuaternion(q){const x=this.x,y=this.y,z=this.z;const qx=q.x,qy=q.y,qz=q.z,qw=q.w;const ix=qw*x+qy*z-qz*y;const iy=qw*y+qz*x-qx*z;const iz=qw*z+qx*y-qy*x;const iw=-qx*x-qy*y-qz*z;this.x=ix*qw+iw*-qx+iy*-qz-iz*-qy;this.y=iy*qw+iw*-qy+iz*-qx-ix*-qz;this.z=iz*qw+iw*-qz+ix*-qy-iy*-qx;return this}setFromMatrixColumn(m,i){return this.fromArray(m.elements,i*4)}equals(v){return v.x===this.x&&v.y===this.y&&v.z===this.z}fromArray(array,offset=0){this.x=array[offset+0];this.y=array[offset+1];this.z=array[offset+2];return this}toArray(array=[],offset=0){array[offset+0]=this.x;array[offset+1]=this.y;array[offset+2]=this.z;return array}}class Quaternion{constructor(x=0,y=0,z=0,w=1){this.x=x;this.y=y;this.z=z;this.w=w}set(x,y,z,w){this.x=x;this.y=y;this.z=z;this.w=w;return this}copy(q){this.x=q.x;this.y=q.y;this.z=q.z;this.w=q.w;return this}inverse(){return this.conjugate().normalize()}conjugate(){this.x*=-1;this.y*=-1;this.z*=-1;return this}dot(q){return this.x*q.x+this.y*q.y+this.z*q.z+this.w*q.w}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this.dot(this)}normalize(){let l=this.length();if(l===0){this.x=0;this.y=0;this.z=0;this.w=1}else{l=1/l;this.x=this.x*l;this.y=this.y*l;this.z=this.z*l;this.w=this.w*l}return this}multiply(q){return this.multiplyQuaternions(this,q)}premultiply(q){return this.multiplyQuaternions(q,this)}multiplyQuaternions(a,b){const qax=a.x,qay=a.y,qaz=a.z,qaw=a.w;const qbx=b.x,qby=b.y,qbz=b.z,qbw=b.w;this.x=qax*qbw+qaw*qbx+qay*qbz-qaz*qby;this.y=qay*qbw+qaw*qby+qaz*qbx-qax*qbz;this.z=qaz*qbw+qaw*qbz+qax*qby-qay*qbx;this.w=qaw*qbw-qax*qbx-qay*qby-qaz*qbz;return this}slerp(q,t){if(t===0)return this;if(t===1)return this.copy(q);const x=this.x,y=this.y,z=this.z,w=this.w;let cosHalfTheta=w*q.w+x*q.x+y*q.y+z*q.z;if(cosHalfTheta<0){this.w=-q.w;this.x=-q.x;this.y=-q.y;this.z=-q.z;cosHalfTheta=-cosHalfTheta}else{this.copy(q)}if(cosHalfTheta>=1){this.w=w;this.x=x;this.y=y;this.z=z;return this}const sinHalfTheta=Math.sqrt(1-cosHalfTheta*cosHalfTheta);if(Math.abs(sinHalfTheta)<.001){this.w=.5*(w+this.w);this.x=.5*(x+this.x);this.y=.5*(y+this.y);this.z=.5*(z+this.z);return this}const halfTheta=Math.atan2(sinHalfTheta,cosHalfTheta);const ratioA=Math.sin((1-t)*halfTheta)/sinHalfTheta;const ratioB=Math.sin(t*halfTheta)/sinHalfTheta;this.w=w*ratioA+this.w*ratioB;this.x=x*ratioA+this.x*ratioB;this.y=y*ratioA+this.y*ratioB;this.z=z*ratioA+this.z*ratioB;return this}setFromRotationMatrix(m){const e=m.elements;const m11=e[0],m12=e[4],m13=e[8];const m21=e[1],m22=e[5],m23=e[9];const m31=e[2],m32=e[6],m33=e[10];const trace=m11+m22+m33;if(trace>0){let s=.5/Math.sqrt(trace+1);this.w=.25/s;this.x=(m32-m23)*s;this.y=(m13-m31)*s;this.z=(m21-m12)*s}else if(m11>m22&&m11>m33){let s=2*Math.sqrt(1+m11-m22-m33);this.w=(m32-m23)/s;this.x=.25*s;this.y=(m12+m21)/s;this.z=(m13+m31)/s}else if(m22>m33){let s=2*Math.sqrt(1+m22-m11-m33);this.w=(m13-m31)/s;this.x=(m12+m21)/s;this.y=.25*s;this.z=(m23+m32)/s}else{let s=2*Math.sqrt(1+m33-m11-m22);this.w=(m21-m12)/s;this.x=(m13+m31)/s;this.y=(m23+m32)/s;this.z=.25*s}return this}equals(q){return q.x===this.x&&q.y===this.y&&q.z===this.z&&q.w===this.w}fromArray(array,offset=0){this.x=array[offset+0];this.y=array[offset+1];this.z=array[offset+2];this.w=array[offset+3];return this}toArray(array=[],offset=0){array[offset+0]=this.x;array[offset+1]=this.y;array[offset+2]=this.z;array[offset+3]=this.w;return array}}const x=new Vector3;const y=new Vector3;const z=new Vector3;class Matrix4{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}set(n11,n12,n13,n14,n21,n22,n23,n24,n31,n32,n33,n34,n41,n42,n43,n44){const e=this.elements;e[0]=n11;e[4]=n12;e[8]=n13;e[12]=n14;e[1]=n21;e[5]=n22;e[9]=n23;e[13]=n24;e[2]=n31;e[6]=n32;e[10]=n33;e[14]=n34;e[3]=n41;e[7]=n42;e[11]=n43;e[15]=n44;return this}identity(){this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return this}extractBasis(xAxis,yAxis,zAxis){xAxis.setFromMatrixColumn(this,0);yAxis.setFromMatrixColumn(this,1);zAxis.setFromMatrixColumn(this,2);return this}makeBasis(xAxis,yAxis,zAxis){this.set(xAxis.x,yAxis.x,zAxis.x,0,xAxis.y,yAxis.y,zAxis.y,0,xAxis.z,yAxis.z,zAxis.z,0,0,0,0,1);return this}multiply(m){return this.multiplyMatrices(this,m)}premultiply(m){return this.multiplyMatrices(m,this)}multiplyMatrices(a,b){const ae=a.elements;const be=b.elements;const e=this.elements;const a11=ae[0],a12=ae[4],a13=ae[8],a14=ae[12];const a21=ae[1],a22=ae[5],a23=ae[9],a24=ae[13];const a31=ae[2],a32=ae[6],a33=ae[10],a34=ae[14];const a41=ae[3],a42=ae[7],a43=ae[11],a44=ae[15];const b11=be[0],b12=be[4],b13=be[8],b14=be[12];const b21=be[1],b22=be[5],b23=be[9],b24=be[13];const b31=be[2],b32=be[6],b33=be[10],b34=be[14];const b41=be[3],b42=be[7],b43=be[11],b44=be[15];e[0]=a11*b11+a12*b21+a13*b31+a14*b41;e[4]=a11*b12+a12*b22+a13*b32+a14*b42;e[8]=a11*b13+a12*b23+a13*b33+a14*b43;e[12]=a11*b14+a12*b24+a13*b34+a14*b44;e[1]=a21*b11+a22*b21+a23*b31+a24*b41;e[5]=a21*b12+a22*b22+a23*b32+a24*b42;e[9]=a21*b13+a22*b23+a23*b33+a24*b43;e[13]=a21*b14+a22*b24+a23*b34+a24*b44;e[2]=a31*b11+a32*b21+a33*b31+a34*b41;e[6]=a31*b12+a32*b22+a33*b32+a34*b42;e[10]=a31*b13+a32*b23+a33*b33+a34*b43;e[14]=a31*b14+a32*b24+a33*b34+a34*b44;e[3]=a41*b11+a42*b21+a43*b31+a44*b41;e[7]=a41*b12+a42*b22+a43*b32+a44*b42;e[11]=a41*b13+a42*b23+a43*b33+a44*b43;e[15]=a41*b14+a42*b24+a43*b34+a44*b44;return this}multiplyScalar(s){const e=this.elements;e[0]*=s;e[4]*=s;e[8]*=s;e[12]*=s;e[1]*=s;e[5]*=s;e[9]*=s;e[13]*=s;e[2]*=s;e[6]*=s;e[10]*=s;e[14]*=s;e[3]*=s;e[7]*=s;e[11]*=s;e[15]*=s;return this}compose(position,quaternion,scale){this.makeRotationFromQuaternion(quaternion);this.scale(scale);this.setPosition(position);return this}makeRotationFromQuaternion(q){const e=this.elements;const x=q.x,y=q.y,z=q.z,w=q.w;const x2=x+x,y2=y+y,z2=z+z;const xx=x*x2,xy=x*y2,xz=x*z2;const yy=y*y2,yz=y*z2,zz=z*z2;const wx=w*x2,wy=w*y2,wz=w*z2;e[0]=1-(yy+zz);e[4]=xy-wz;e[8]=xz+wy;e[1]=xy+wz;e[5]=1-(xx+zz);e[9]=yz-wx;e[2]=xz-wy;e[6]=yz+wx;e[10]=1-(xx+yy);e[3]=0;e[7]=0;e[11]=0;e[12]=0;e[13]=0;e[14]=0;e[15]=1;return this}scale(v){const e=this.elements;const x=v.x,y=v.y,z=v.z;e[0]*=x;e[4]*=y;e[8]*=z;e[1]*=x;e[5]*=y;e[9]*=z;e[2]*=x;e[6]*=y;e[10]*=z;e[3]*=x;e[7]*=y;e[11]*=z;return this}setPosition(v){const e=this.elements;e[12]=v.x;e[13]=v.y;e[14]=v.z;return this}transpose(){const e=this.elements;let t;t=e[1];e[1]=e[4];e[4]=t;t=e[2];e[2]=e[8];e[8]=t;t=e[6];e[6]=e[9];e[9]=t;t=e[3];e[3]=e[12];e[12]=t;t=e[7];e[7]=e[13];e[13]=t;t=e[11];e[11]=e[14];e[14]=t;return this}getInverse(m){const e=this.elements;const me=m.elements;const n11=me[0],n21=me[1],n31=me[2],n41=me[3];const n12=me[4],n22=me[5],n32=me[6],n42=me[7];const n13=me[8],n23=me[9],n33=me[10],n43=me[11];const n14=me[12],n24=me[13],n34=me[14],n44=me[15];const t11=n23*n34*n42-n24*n33*n42+n24*n32*n43-n22*n34*n43-n23*n32*n44+n22*n33*n44;const t12=n14*n33*n42-n13*n34*n42-n14*n32*n43+n12*n34*n43+n13*n32*n44-n12*n33*n44;const t13=n13*n24*n42-n14*n23*n42+n14*n22*n43-n12*n24*n43-n13*n22*n44+n12*n23*n44;const t14=n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*n22*n34-n12*n23*n34;const det=n11*t11+n21*t12+n31*t13+n41*t14;if(det===0){console.warn("YUKA.Matrix4: .getInverse() can not invert matrix, determinant is 0.");return this.identity()}const detInv=1/det;e[0]=t11*detInv;e[1]=(n24*n33*n41-n23*n34*n41-n24*n31*n43+n21*n34*n43+n23*n31*n44-n21*n33*n44)*detInv;e[2]=(n22*n34*n41-n24*n32*n41+n24*n31*n42-n21*n34*n42-n22*n31*n44+n21*n32*n44)*detInv;e[3]=(n23*n32*n41-n22*n33*n41-n23*n31*n42+n21*n33*n42+n22*n31*n43-n21*n32*n43)*detInv;e[4]=t12*detInv;e[5]=(n13*n34*n41-n14*n33*n41+n14*n31*n43-n11*n34*n43-n13*n31*n44+n11*n33*n44)*detInv;e[6]=(n14*n32*n41-n12*n34*n41-n14*n31*n42+n11*n34*n42+n12*n31*n44-n11*n32*n44)*detInv;e[7]=(n12*n33*n41-n13*n32*n41+n13*n31*n42-n11*n33*n42-n12*n31*n43+n11*n32*n43)*detInv;e[8]=t13*detInv;e[9]=(n14*n23*n41-n13*n24*n41-n14*n21*n43+n11*n24*n43+n13*n21*n44-n11*n23*n44)*detInv;e[10]=(n12*n24*n41-n14*n22*n41+n14*n21*n42-n11*n24*n42-n12*n21*n44+n11*n22*n44)*detInv;e[11]=(n13*n22*n41-n12*n23*n41-n13*n21*n42+n11*n23*n42+n12*n21*n43-n11*n22*n43)*detInv;e[12]=t14*detInv;e[13]=(n13*n24*n31-n14*n23*n31+n14*n21*n33-n11*n24*n33-n13*n21*n34+n11*n23*n34)*detInv;e[14]=(n14*n22*n31-n12*n24*n31-n14*n21*n32+n11*n24*n32+n12*n21*n34-n11*n22*n34)*detInv;e[15]=(n12*n23*n31-n13*n22*n31+n13*n21*n32-n11*n23*n32-n12*n21*n33+n11*n22*n33)*detInv;return this}lookAt(eye,target,up){z.subVectors(eye,target);if(z.lengthSquared()===0){z.z=1}z.normalize();x.crossVectors(up,z);if(x.lengthSquared()===0){if(Math.abs(up.z)===1){z.x+=1e-4}else{z.z+=1e-4}z.normalize();x.crossVectors(up,z)}x.normalize();y.crossVectors(z,x);const e=this.elements;e[0]=x.x;e[4]=y.x;e[8]=z.x;e[1]=x.y;e[5]=y.y;e[9]=z.y;e[2]=x.z;e[6]=y.z;e[10]=z.z;return this}equals(m){const e=this.elements;const me=m.elements;for(let i=0;i<16;i++){if(e[i]!==me[i])return false}return true}fromArray(array,offset=0){const e=this.elements;for(let i=0;i<16;i++){e[i]=array[i+offset]}return this}toArray(array=[],offset=0){const e=this.elements;array[offset+0]=e[0];array[offset+1]=e[1];array[offset+2]=e[2];array[offset+3]=e[3];array[offset+4]=e[4];array[offset+5]=e[5];array[offset+6]=e[6];array[offset+7]=e[7];array[offset+8]=e[8];array[offset+9]=e[9];array[offset+10]=e[10];array[offset+11]=e[11];array[offset+12]=e[12];array[offset+13]=e[13];array[offset+14]=e[14];array[offset+15]=e[15];return array}}class GameEntity{constructor(){this.manager=null;this.id=GameEntity.__nextId++;this.name="";this.tag="";this.position=new Vector3;this.rotation=new Quaternion;this.scale=new Vector3(1,1,1);this.up=new Vector3(0,1,0);this.boundingRadius=0;this.matrix=new Matrix4}update(){}sendMessage(receiver,message,delay=0,data=null){this.manager.sendMessage(this,receiver,message,delay,data)}handleMessage(){return false}updateMatrix(){this.matrix.compose(this.position,this.rotation,this.scale)}}GameEntity.__nextId=0;const direction=new Vector3;const rotationMatrix=new Matrix4;const targetRotation=new Quaternion;class MovingEntity extends GameEntity{constructor(){super();this.velocity=new Vector3;this.mass=1;this.maxSpeed=1;this.maxForce=100;this.maxTurnRate=Math.PI}rotateToTarget(target){this.getDirection(direction);const angle=target.angleTo(direction);if(angle<1e-5)return true;const t=angle>this.maxTurnRate?this.maxTurnRate/angle:1;rotationMatrix.lookAt(target,this.position,this.up);targetRotation.setFromRotationMatrix(rotationMatrix);this.rotation.slerp(targetRotation,t);this.velocity.applyQuaternion(this.rotation);return false}lookAt(target){rotationMatrix.lookAt(target,this.position,this.up);this.rotation.setFromRotationMatrix(rotationMatrix);return this}getDirection(result=new Vector3){return result.set(0,0,1).applyQuaternion(this.rotation).normalize()}getSpeed(){return this.velocity.length()}getSpeedSquared(){return this.velocity.lengthSquared()}}class Path{constructor(){this.loop=false;this._waypoints=[];this._index=0}add(waypoint){this._waypoints.push(waypoint);return this}clea(){this._waypoints.length=0;return this}finished(){const lastIndex=this._waypoints.length-1;return this.loop===true?false:this._index===lastIndex}advance(){this._index++;if(this._index===this._waypoints.length){if(this.loop===true){this._index=0}else{this._index--}}return this}current(){return this._waypoints[this._index]}}const _Math$1={clamp:(value,min,max)=>{return Math.max(min,Math.min(max,value))},randFloat:(min,max)=>{return min+Math.random()*(max-min)}};class Vector3$1{constructor(x=0,y=0,z=0){this.x=x;this.y=y;this.z=z}set(x,y,z){this.x=x;this.y=y;this.z=z;return this}copy(v){this.x=v.x;this.y=v.y;this.z=v.z;return this}add(v){this.x+=v.x;this.y+=v.y;this.z+=v.z;return this}addScalar(s){this.x+=s;this.y+=s;this.z+=s;return this}addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;return this}sub(v){this.x-=v.x;this.y-=v.y;this.z-=v.z;return this}subScalar(s){this.x-=s;this.y-=s;this.z-=s;return this}subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;return this}multiply(v){this.x*=v.x;this.y*=v.y;this.z*=v.z;return this}multiplyScalar(s){this.x*=s;this.y*=s;this.z*=s;return this}multiplyVectors(a,b){this.x=a.x*b.x;this.y=a.y*b.y;this.z=a.z*b.z;return this}divide(v){this.x/=v.x;this.y/=v.y;this.z/=v.z;return this}divideScalar(s){this.x/=s;this.y/=s;this.z/=s;return this}divideVectors(a,b){this.x=a.x/b.x;this.y=a.y/b.y;this.z=a.z/b.z;return this}dot(v){return this.x*v.x+this.y*v.y+this.z*v.z}cross(v){const x=this.x,y=this.y,z=this.z;this.x=y*v.z-z*v.y;this.y=z*v.x-x*v.z;this.z=x*v.y-y*v.x;return this}crossVectors(a,b){const ax=a.x,ay=a.y,az=a.z;const bx=b.x,by=b.y,bz=b.z;this.x=ay*bz-az*by;this.y=az*bx-ax*bz;this.z=ax*by-ay*bx;return this}angleTo(v){const theta=this.dot(v)/Math.sqrt(this.lengthSq()*v.lengthSq());return Math.acos(_Math$1.clamp(theta,-1,1))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this.dot(this)}distanceTo(v){return Math.sqrt(this.distanceToSquared(v))}distanceToSquared(v){const dx=this.x-v.x,dy=this.y-v.y,dz=this.z-v.z;return dx*dx+dy*dy+dz*dz}normalize(){return this.divideScalar(this.length()||1)}applyMatrix4(m){const x=this.x,y=this.y,z=this.z;const e=m.elements;const w=1/(e[3]*x+e[7]*y+e[11]*z+e[15]);this.x=(e[0]*x+e[4]*y+e[8]*z+e[12])*w;this.y=(e[1]*x+e[5]*y+e[9]*z+e[13])*w;this.z=(e[2]*x+e[6]*y+e[10]*z+e[14])*w;return this}applyQuaternion(q){const x=this.x,y=this.y,z=this.z;const qx=q.x,qy=q.y,qz=q.z,qw=q.w;const ix=qw*x+qy*z-qz*y;const iy=qw*y+qz*x-qx*z;const iz=qw*z+qx*y-qy*x;const iw=-qx*x-qy*y-qz*z;this.x=ix*qw+iw*-qx+iy*-qz-iz*-qy;this.y=iy*qw+iw*-qy+iz*-qx-ix*-qz;this.z=iz*qw+iw*-qz+ix*-qy-iy*-qx;return this}setFromMatrixColumn(m,i){return this.fromArray(m.elements,i*4)}equals(v){return v.x===this.x&&v.y===this.y&&v.z===this.z}fromArray(array,offset=0){this.x=array[offset+0];this.y=array[offset+1];this.z=array[offset+2];return this}toArray(array=[],offset=0){array[offset+0]=this.x;array[offset+1]=this.y;array[offset+2]=this.z;return array}}const force=new Vector3$1;class SteeringManager{constructor(vehicle){this.vehicle=vehicle;this.behaviors=[];this._steeringForce=new Vector3$1}add(behavior){this.behaviors.push(behavior);return this}remove(behavior){const index=this.behaviors.indexOf(behavior);this.behaviors.splice(index,1);return this}_calculate(delta,optionalTarget){const result=optionalTarget||new Vector3$1;this._calculateByOrder(delta);return result.copy(this._steeringForce)}_accumulate(forceToAdd){const magnitudeSoFar=this._steeringForce.length();const magnitudeRemaining=this.vehicle.maxForce-magnitudeSoFar;if(magnitudeRemaining<=0)return false;const magnitudeToAdd=forceToAdd.length();if(magnitudeToAdd>magnitudeRemaining){forceToAdd.normalize().multiplyScalar(magnitudeRemaining)}this._steeringForce.add(forceToAdd);return true}_calculateByOrder(delta){this._steeringForce.set(0,0,0);for(let behavior of this.behaviors){force.set(0,0,0);behavior.calculate(this.vehicle,force,delta);force.multiplyScalar(behavior.weigth);if(this._accumulate(force)===false)return}}}class Smoother{constructor(count=10){this.count=count;this._history=[];this._slot=0;for(let i=0;i<this.count;i++){this._history[i]=new Vector3$1}}update(value,average){average.set(0,0,0);if(this._slot===this.count){this._slot=0}this._history[this._slot].copy(value);this._slot++;for(let i=0;i<this.count;i++){average.add(this._history[i])}average.divideScalar(this.count)}}const steeringForce=new Vector3;const displacement=new Vector3;const acceleration=new Vector3;const target=new Vector3;const rotationMatrix$1=new Matrix4;class Vehicle extends MovingEntity{constructor(){super();this.steering=new SteeringManager(this);this._smoother=null;this._smoothedVelocity=new Vector3;this.rotationSmooth=new Quaternion}enableSmoothing(sampleCount){this._smoother=new Smoother(sampleCount)}disableSmoothing(){this._smoother=null}update(delta){this.steering._calculate(delta,steeringForce);acceleration.copy(steeringForce).divideScalar(this.mass);this.velocity.add(acceleration.multiplyScalar(delta));if(this.getSpeedSquared()>this.maxSpeed*this.maxSpeed){this.velocity.normalize();this.velocity.multiplyScalar(this.maxSpeed)}displacement.copy(this.velocity).multiplyScalar(delta);target.copy(this.position).add(displacement);if(this.getSpeedSquared()>1e-8){this.lookAt(target)}this.position.copy(target);if(this._smoother!==null){this._smoother.update(this.velocity,this._smoothedVelocity);displacement.copy(this._smoothedVelocity).multiplyScalar(delta);target.copy(this.position).add(displacement);rotationMatrix$1.lookAt(target,this.position,this.up);this.rotationSmooth.setFromRotationMatrix(rotationMatrix$1)}}}class SteeringBehavior{constructor(){this.weigth=1}calculate(){}}const desiredVelocity=new Vector3$1;const displacement$1=new Vector3$1;class ArriveBehavior extends SteeringBehavior{constructor(target,deceleration=3){super();this.target=target;this.deceleration=deceleration}calculate(vehicle,force){const target=this.target;const deceleration=this.deceleration;displacement$1.subVectors(target,vehicle.position);const distance=displacement$1.length();if(distance>0){let speed=distance/deceleration;speed=Math.min(speed,vehicle.maxSpeed);desiredVelocity.copy(displacement$1).multiplyScalar(speed/distance);force.subVectors(desiredVelocity,vehicle.velocity)}}}const desiredVelocity$1=new Vector3$1;class FleeBehavior extends SteeringBehavior{constructor(target,panicDistance=10){super();this.target=target;this.panicDistance=panicDistance}calculate(vehicle,force){const target=this.target;const distanceToTargetSq=vehicle.position.distanceToSquared(target);if(distanceToTargetSq<this.panicDistance*this.panicDistance){desiredVelocity$1.subVectors(vehicle.position,target).normalize();if(desiredVelocity$1.lengthSquared()===0){desiredVelocity$1.set(0,0,1)}desiredVelocity$1.multiplyScalar(vehicle.maxSpeed);force.subVectors(desiredVelocity$1,vehicle.velocity)}}}const displacement$2=new Vector3$1;const newPuruserVelocity=new Vector3$1;const predcitedPosition=new Vector3$1;class EvadeBehavior extends SteeringBehavior{constructor(target,pursuer){super();this.target=target;this.pursuer=pursuer;this._flee=new FleeBehavior}calculate(vehicle,force){const pursuer=this.pursuer;displacement$2.subVectors(pursuer.position,vehicle.position);const lookAheadTime=displacement$2.length()/(vehicle.maxSpeed+pursuer.getSpeed());newPuruserVelocity.copy(pursuer.velocity).multiplyScalar(lookAheadTime);predcitedPosition.addVectors(pursuer.position,newPuruserVelocity);this._flee.target=predcitedPosition;this._flee.calculate(vehicle,force)}}const desiredVelocity$2=new Vector3$1;class SeekBehavior extends SteeringBehavior{constructor(target){super();this.target=target}calculate(vehicle,force){const target=this.target;desiredVelocity$2.subVectors(target,vehicle.position).normalize();desiredVelocity$2.multiplyScalar(vehicle.maxSpeed);force.subVectors(desiredVelocity$2,vehicle.velocity)}}class FollowPathBehavior extends SteeringBehavior{constructor(path){super();this.path=path;this._nextWaypointDistance=1;this._seek=new SeekBehavior;this._arrive=new ArriveBehavior}calculate(vehicle,force){const path=this.path;const nextWaypointDistance=this._nextWaypointDistance;var distanceSq=path.current().distanceToSquared(vehicle.position);if(distanceSq<nextWaypointDistance*nextWaypointDistance){path.advance()}const target=path.current();if(path.finished()===true){this._arrive.target=target;this._arrive.calculate(vehicle,force)}else{this._seek.target=target;this._seek.calculate(vehicle,force)}}}const x$1=new Vector3$1;const y$1=new Vector3$1;const z$1=new Vector3$1;class Matrix4$1{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}set(n11,n12,n13,n14,n21,n22,n23,n24,n31,n32,n33,n34,n41,n42,n43,n44){const e=this.elements;e[0]=n11;e[4]=n12;e[8]=n13;e[12]=n14;e[1]=n21;e[5]=n22;e[9]=n23;e[13]=n24;e[2]=n31;e[6]=n32;e[10]=n33;e[14]=n34;e[3]=n41;e[7]=n42;e[11]=n43;e[15]=n44;return this}identity(){this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return this}extractBasis(xAxis,yAxis,zAxis){xAxis.setFromMatrixColumn(this,0);yAxis.setFromMatrixColumn(this,1);zAxis.setFromMatrixColumn(this,2);return this}makeBasis(xAxis,yAxis,zAxis){this.set(xAxis.x,yAxis.x,zAxis.x,0,xAxis.y,yAxis.y,zAxis.y,0,xAxis.z,yAxis.z,zAxis.z,0,0,0,0,1);return this}multiply(m){return this.multiplyMatrices(this,m)}premultiply(m){return this.multiplyMatrices(m,this)}multiplyMatrices(a,b){const ae=a.elements;const be=b.elements;const e=this.elements;const a11=ae[0],a12=ae[4],a13=ae[8],a14=ae[12];const a21=ae[1],a22=ae[5],a23=ae[9],a24=ae[13];const a31=ae[2],a32=ae[6],a33=ae[10],a34=ae[14];const a41=ae[3],a42=ae[7],a43=ae[11],a44=ae[15];const b11=be[0],b12=be[4],b13=be[8],b14=be[12];const b21=be[1],b22=be[5],b23=be[9],b24=be[13];const b31=be[2],b32=be[6],b33=be[10],b34=be[14];const b41=be[3],b42=be[7],b43=be[11],b44=be[15];e[0]=a11*b11+a12*b21+a13*b31+a14*b41;e[4]=a11*b12+a12*b22+a13*b32+a14*b42;e[8]=a11*b13+a12*b23+a13*b33+a14*b43;e[12]=a11*b14+a12*b24+a13*b34+a14*b44;e[1]=a21*b11+a22*b21+a23*b31+a24*b41;e[5]=a21*b12+a22*b22+a23*b32+a24*b42;e[9]=a21*b13+a22*b23+a23*b33+a24*b43;e[13]=a21*b14+a22*b24+a23*b34+a24*b44;e[2]=a31*b11+a32*b21+a33*b31+a34*b41;e[6]=a31*b12+a32*b22+a33*b32+a34*b42;e[10]=a31*b13+a32*b23+a33*b33+a34*b43;e[14]=a31*b14+a32*b24+a33*b34+a34*b44;e[3]=a41*b11+a42*b21+a43*b31+a44*b41;e[7]=a41*b12+a42*b22+a43*b32+a44*b42;e[11]=a41*b13+a42*b23+a43*b33+a44*b43;e[15]=a41*b14+a42*b24+a43*b34+a44*b44;return this}multiplyScalar(s){const e=this.elements;e[0]*=s;e[4]*=s;e[8]*=s;e[12]*=s;e[1]*=s;e[5]*=s;e[9]*=s;e[13]*=s;e[2]*=s;e[6]*=s;e[10]*=s;e[14]*=s;e[3]*=s;e[7]*=s;e[11]*=s;e[15]*=s;return this}compose(position,quaternion,scale){this.makeRotationFromQuaternion(quaternion);this.scale(scale);this.setPosition(position);return this}makeRotationFromQuaternion(q){const e=this.elements;const x=q.x,y=q.y,z=q.z,w=q.w;const x2=x+x,y2=y+y,z2=z+z;const xx=x*x2,xy=x*y2,xz=x*z2;const yy=y*y2,yz=y*z2,zz=z*z2;const wx=w*x2,wy=w*y2,wz=w*z2;e[0]=1-(yy+zz);e[4]=xy-wz;e[8]=xz+wy;e[1]=xy+wz;e[5]=1-(xx+zz);e[9]=yz-wx;e[2]=xz-wy;e[6]=yz+wx;e[10]=1-(xx+yy);e[3]=0;e[7]=0;e[11]=0;e[12]=0;e[13]=0;e[14]=0;e[15]=1;return this}scale(v){const e=this.elements;const x=v.x,y=v.y,z=v.z;e[0]*=x;e[4]*=y;e[8]*=z;e[1]*=x;e[5]*=y;e[9]*=z;e[2]*=x;e[6]*=y;e[10]*=z;e[3]*=x;e[7]*=y;e[11]*=z;return this}setPosition(v){const e=this.elements;e[12]=v.x;e[13]=v.y;e[14]=v.z;return this}transpose(){const e=this.elements;let t;t=e[1];e[1]=e[4];e[4]=t;t=e[2];e[2]=e[8];e[8]=t;t=e[6];e[6]=e[9];e[9]=t;t=e[3];e[3]=e[12];e[12]=t;t=e[7];e[7]=e[13];e[13]=t;t=e[11];e[11]=e[14];e[14]=t;return this}getInverse(m){const e=this.elements;const me=m.elements;const n11=me[0],n21=me[1],n31=me[2],n41=me[3];const n12=me[4],n22=me[5],n32=me[6],n42=me[7];const n13=me[8],n23=me[9],n33=me[10],n43=me[11];const n14=me[12],n24=me[13],n34=me[14],n44=me[15];const t11=n23*n34*n42-n24*n33*n42+n24*n32*n43-n22*n34*n43-n23*n32*n44+n22*n33*n44;const t12=n14*n33*n42-n13*n34*n42-n14*n32*n43+n12*n34*n43+n13*n32*n44-n12*n33*n44;const t13=n13*n24*n42-n14*n23*n42+n14*n22*n43-n12*n24*n43-n13*n22*n44+n12*n23*n44;const t14=n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*n22*n34-n12*n23*n34;const det=n11*t11+n21*t12+n31*t13+n41*t14;if(det===0){console.warn("YUKA.Matrix4: .getInverse() can not invert matrix, determinant is 0.");return this.identity()}const detInv=1/det;e[0]=t11*detInv;e[1]=(n24*n33*n41-n23*n34*n41-n24*n31*n43+n21*n34*n43+n23*n31*n44-n21*n33*n44)*detInv;e[2]=(n22*n34*n41-n24*n32*n41+n24*n31*n42-n21*n34*n42-n22*n31*n44+n21*n32*n44)*detInv;e[3]=(n23*n32*n41-n22*n33*n41-n23*n31*n42+n21*n33*n42+n22*n31*n43-n21*n32*n43)*detInv;e[4]=t12*detInv;e[5]=(n13*n34*n41-n14*n33*n41+n14*n31*n43-n11*n34*n43-n13*n31*n44+n11*n33*n44)*detInv;e[6]=(n14*n32*n41-n12*n34*n41-n14*n31*n42+n11*n34*n42+n12*n31*n44-n11*n32*n44)*detInv;e[7]=(n12*n33*n41-n13*n32*n41+n13*n31*n42-n11*n33*n42-n12*n31*n43+n11*n32*n43)*detInv;e[8]=t13*detInv;e[9]=(n14*n23*n41-n13*n24*n41-n14*n21*n43+n11*n24*n43+n13*n21*n44-n11*n23*n44)*detInv;e[10]=(n12*n24*n41-n14*n22*n41+n14*n21*n42-n11*n24*n42-n12*n21*n44+n11*n22*n44)*detInv;e[11]=(n13*n22*n41-n12*n23*n41-n13*n21*n42+n11*n23*n42+n12*n21*n43-n11*n22*n43)*detInv;e[12]=t14*detInv;e[13]=(n13*n24*n31-n14*n23*n31+n14*n21*n33-n11*n24*n33-n13*n21*n34+n11*n23*n34)*detInv;e[14]=(n14*n22*n31-n12*n24*n31-n14*n21*n32+n11*n24*n32+n12*n21*n34-n11*n22*n34)*detInv;e[15]=(n12*n23*n31-n13*n22*n31+n13*n21*n32-n11*n23*n32-n12*n21*n33+n11*n22*n33)*detInv;return this}lookAt(eye,target,up){z$1.subVectors(eye,target);if(z$1.lengthSquared()===0){z$1.z=1}z$1.normalize();x$1.crossVectors(up,z$1);if(x$1.lengthSquared()===0){if(Math.abs(up.z)===1){z$1.x+=1e-4}else{z$1.z+=1e-4}z$1.normalize();x$1.crossVectors(up,z$1)}x$1.normalize();y$1.crossVectors(z$1,x$1);const e=this.elements;e[0]=x$1.x;e[4]=y$1.x;e[8]=z$1.x;e[1]=x$1.y;e[5]=y$1.y;e[9]=z$1.y;e[2]=x$1.z;e[6]=y$1.z;e[10]=z$1.z;return this}equals(m){const e=this.elements;const me=m.elements;for(let i=0;i<16;i++){if(e[i]!==me[i])return false}return true}fromArray(array,offset=0){const e=this.elements;for(let i=0;i<16;i++){e[i]=array[i+offset]}return this}toArray(array=[],offset=0){const e=this.elements;array[offset+0]=e[0];array[offset+1]=e[1];array[offset+2]=e[2];array[offset+3]=e[3];array[offset+4]=e[4];array[offset+5]=e[5];array[offset+6]=e[6];array[offset+7]=e[7];array[offset+8]=e[8];array[offset+9]=e[9];array[offset+10]=e[10];array[offset+11]=e[11];array[offset+12]=e[12];array[offset+13]=e[13];array[offset+14]=e[14];array[offset+15]=e[15];return array}}const v1=new Vector3$1;class Ray{constructor(origin=new Vector3$1,direction=new Vector3$1){this.origin=origin;this.direction=direction}set(origin,direction){this.origin.copy(origin);this.direction.copy(direction);return this}copy(ray){this.origin.copy(ray.origin);this.direction.copy(ray.direction);return this}at(t,result=new Vector3$1){return result.copy(this.direction).multiplyScalar(t).add(this.origin)}intersectSphere(center,radius,result=new Vector3$1){v1.subVectors(center,this.origin);const tca=v1.dot(this.direction);const d2=v1.dot(v1)-tca*tca;const radius2=radius*radius;if(d2>radius2)return null;const thc=Math.sqrt(radius2-d2);const t0=tca-thc;const t1=tca+thc;if(t0<0&&t1<0)return null;if(t0<0)return this.at(t1,result);return this.at(t0,result)}equals(ray){return ray.origin.equals(this.origin)&&ray.direction.equals(this.direction)}}const inverse=new Matrix4$1;const localPositionOfObstacle=new Vector3$1;const localPositionOfClosestObstacle=new Vector3$1;const intersectionPoint=new Vector3$1;const ray=new Ray(new Vector3$1(0,0,0),new Vector3$1(0,0,1));class ObstacleAvoidanceBehavior extends SteeringBehavior{constructor(entityManager){super();this.entityManager=entityManager;this.weigth=3;this.brakingWeight=.2;this.dBoxMinLength=5}calculate(vehicle,force){let closestObstacle=null;let distanceToClosestObstacle=Infinity;const obstacles=this.entityManager.entities.values();const dBoxLength=this.dBoxMinLength+vehicle.getSpeed()/vehicle.maxSpeed*this.dBoxMinLength;inverse.getInverse(vehicle.matrix);for(let obstacle of obstacles){if(obstacle===vehicle)continue;localPositionOfObstacle.copy(obstacle.position).applyMatrix4(inverse);if(localPositionOfObstacle.z>0&&Math.abs(localPositionOfObstacle.z)<dBoxLength){const expandedRadius=obstacle.boundingRadius+vehicle.boundingRadius;if(Math.abs(localPositionOfObstacle.x)<expandedRadius){ray.intersectSphere(localPositionOfObstacle,expandedRadius,intersectionPoint);if(intersectionPoint.z<distanceToClosestObstacle){distanceToClosestObstacle=intersectionPoint.z;closestObstacle=obstacle;localPositionOfClosestObstacle.copy(localPositionOfObstacle)}}}}if(closestObstacle!==null){const multiplier=1+(dBoxLength-localPositionOfClosestObstacle.z)/dBoxLength;force.x=(closestObstacle.boundingRadius-localPositionOfClosestObstacle.x)*multiplier;force.z=(closestObstacle.boundingRadius-localPositionOfClosestObstacle.z)*this.brakingWeight;force.applyQuaternion(vehicle.rotation)}}}const displacement$3=new Vector3$1;const vehicleDirection=new Vector3$1;const evaderDirection=new Vector3$1;const newEvaderVelocity=new Vector3$1;const predcitedPosition$1=new Vector3$1;class PursuitBehavior extends SteeringBehavior{constructor(target,evader){super();this.target=target;this.evader=evader;this._seek=new SeekBehavior}calculate(vehicle,force){const evader=this.evader;displacement$3.subVectors(evader.position,vehicle.position);vehicle.getDirection(vehicleDirection);evader.getDirection(evaderDirection);const evaderAhead=displacement$3.dot(vehicleDirection)>0;const facing=vehicleDirection.dot(evaderDirection)<-.95;if(evaderAhead===true&&facing===true){this._seek(force,evader.position);return}const lookAheadTime=displacement$3.length()/(vehicle.maxSpeed+evader.getSpeed());newEvaderVelocity.copy(evader.velocity).multiplyScalar(lookAheadTime);predcitedPosition$1.addVectors(evader.position,newEvaderVelocity);this._seek.target=predcitedPosition$1;this._seek.calculate(force)}}const targetWorld=new Vector3$1;const randomDisplacement=new Vector3$1;class WanderBehavior extends SteeringBehavior{constructor(radius=2,distance=10,jitter=20){super();this.radius=radius;this.distance=distance;this.jitter=jitter;this._targetLocal=new Vector3$1;this._setup()}calculate(vehicle,force,delta){const jitterThisTimeSlice=this.jitter*delta;randomDisplacement.x=_Math$1.randFloat(-1,1)*jitterThisTimeSlice;randomDisplacement.z=_Math$1.randFloat(-1,1)*jitterThisTimeSlice;this._targetLocal.add(randomDisplacement);this._targetLocal.normalize();this._targetLocal.multiplyScalar(this.radius);targetWorld.copy(this._targetLocal);targetWorld.z+=this.distance;targetWorld.applyMatrix4(vehicle.matrix);force.subVectors(targetWorld,vehicle.position)}_setup(){var theta=Math.random()*Math.PI*2;this._targetLocal.x=this.radius*Math.cos(theta);this._targetLocal.z=this.radius*Math.sin(theta)}}class State{enter(){}execute(){console.warn("YUKA.State: .execute() must be implemented in derived class.")}exit(){}onMessage(){return false}}class StateMachine{constructor(owner){this.owner=owner;this.currentState=null;this.previousState=null;this.globalState=null}update(){if(this.globalState!==null){this.globalState.execute(this.owner)}if(this.currentState!==null){this.currentState.execute(this.owner)}}changeState(newState){if(newState instanceof State){this.previousState=this.currentState;this.currentState.exit(this.owner);this.currentState=newState;this.currentState.enter(this.owner)}else{console.warn('YUKA.StateMachine: .changeState() needs a parameter of type "YUKA.State".')}}revertToPrevoiusState(){this.changeState(this.previousState)}inState(state){return state===this.currentState}handleMessage(telegram){if(this.currentState!==null&&this.currentState.onMessage(this.owner,telegram)===true){return true}if(this.globalState!==null&&this.globalState.onMessage(this.owner,telegram)===true){return true}return false}}const v1$1=new Vector3;class Ray$1{constructor(origin=new Vector3,direction=new Vector3){this.origin=origin;this.direction=direction}set(origin,direction){this.origin.copy(origin);this.direction.copy(direction);return this}copy(ray){this.origin.copy(ray.origin);this.direction.copy(ray.direction);return this}at(t,result=new Vector3){return result.copy(this.direction).multiplyScalar(t).add(this.origin)}intersectSphere(center,radius,result=new Vector3){v1$1.subVectors(center,this.origin);const tca=v1$1.dot(this.direction);const d2=v1$1.dot(v1$1)-tca*tca;const radius2=radius*radius;if(d2>radius2)return null;const thc=Math.sqrt(radius2-d2);const t0=tca-thc;const t1=tca+thc;if(t0<0&&t1<0)return null;if(t0<0)return this.at(t1,result);return this.at(t0,result)}equals(ray){return ray.origin.equals(this.origin)&&ray.direction.equals(this.direction)}}exports.EntityManager=EntityManager;exports.GameEntity=GameEntity;exports.MovingEntity=MovingEntity;exports.Path=Path;exports.Vehicle=Vehicle;exports.ArriveBehavior=ArriveBehavior;exports.EvadeBehavior=EvadeBehavior;exports.FleeBehavior=FleeBehavior;exports.FollowPathBehavior=FollowPathBehavior;exports.ObstacleAvoidanceBehavior=ObstacleAvoidanceBehavior;exports.PursuitBehavior=PursuitBehavior;exports.SeekBehavior=SeekBehavior;exports.WanderBehavior=WanderBehavior;exports.State=State;exports.StateMachine=StateMachine;exports._Math=_Math;exports.Matrix4=Matrix4;exports.Quaternion=Quaternion;exports.Ray=Ray$1;exports.Vector3=Vector3;Object.defineProperty(exports,"__esModule",{value:true})});
